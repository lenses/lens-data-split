<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../core-collapse/core-collapse.html">
<link rel="import" href="../core-selector/core-selector.html">
<link rel="import" href="../core-input/core-input.html">
<!--
A Thelma component to split a column into columns based on a string separator

##### Example

    <th-data-split></th-data-split>

@element th-data-split
@blurb Split data into multiple columns. Splits at the separator, defaults to comma
@status alpha
@homepage http://thelmanews.github.io/th-data-split/demo.html
-->

<polymer-element name="th-data-split" attributes="input output splitCol splitChar splitColNames">
  <template>
    <link rel="stylesheet" href="th-data-split.css">

    <template if="{{!included}}">
      <core-icon-button icon="perm-data-setting" on-click="{{showControls}}"></core-icon-button>
    </template>

    <!--core-collapse shows table settings. Toggled off by default-->
    <core-collapse id="ctrl_collapse" opened="false">
      <p class="info">Apply a filter on a column to narrow down the results.</p>
      <label for="func_selector">Filter on column:</label>
      <core-selector id="value_selector" selected="{{splitCol}}" valueattr="label">
        <template repeat="{{attr in _dataAttributes}}">
          <div class="col" label="{{attr}}">{{attr}}</div>
        </template>
      </core-selector>
      <label>split by:</label>
      <input is="core-input" value="{{splitChar}}">
      <label>New column labels:</label>
      <template repeat="{{name, index in splitColNames}}">
        <input is="core-input" value="{{name}}" _index="{{index}}" class="col-name" on-change="{{_splitNameChanged}}" >
      </template>
    </core-collapse>

  </template>
  <script>
    Polymer({

      /**
       * Input data
       *
       * @property input
       * @type object
       * @default undefined
       */

      /**
       * Output data
       *
       * @property output
       * @type object
       * @default undefined
       */

      /**
       * Split character. Defaults to ',''
       *
       * @property splitChar
       * @type string
       * @default ,
       */
      splitChar: ',',

      /**
       * Name of the original column that will be split.
       *
       * @property splitCol
       * @type array
       * @default undefined
       */
      splitCol: [],

      /**
       * Names of the new columns generated after the split.
       *
       * @property splitColNames
       * @type array
       * @default []
       */
      splitColNames: [],


      /**
       *  Fired when this polymer element is ready
       *  
       *  @event ready
       */
      ready: function () {
        //open the collapse if the component is included
        if(this.included && !this.$.ctrl_collapse.opened) {
          this.$.ctrl_collapse.toggle();
        }
      },

      /**
       *  Fired automatically when the input is changed.
       *  This event parses input data, then
       *  calls a private event to recalculate output.
       *  
       *  @event inputChanged
       */
      inputChanged: function() {
        var self = this;
        var firstItem = self.input[0];
        if(!firstItem) {
          return;
        }
        var attributes = Object.keys(firstItem);
        
        if(JSON.stringify(self._dataAttributes) === JSON.stringify(attributes) ) {
          //self._mapChartData();
        }
        else {
          self._dataAttributes = attributes;
        }

        self._calculateOutput();
      }, 

      _calculateOutput: function() {
        var self = this;
        if(self.splitCol && self.splitChar && self.splitChar.length>0)
        {
          if(typeof self.input[0][self.splitCol]==="string") {  //TODO: catch exception for split instead?

            self.output = self.input.map(function(item) {
              var splits = item[self.splitCol].split(self.splitChar);
              if(self.splitColNames.length===0 || self.splitColNames.length!==splits.length) {
                self._generateColumnNames(splits.length);
              }
              //clone item
              var ret = {};
              var keys = Object.keys(item);
              keys.forEach(function(key) {
                ret[key] = item[key];
              });
              splits.forEach(function(split, index) {
                ret[self.splitColNames[index]] = splits[index].trim();
              });
              return ret;
            });
          }
          else {
            //error
          }
        }
      },

      _generateColumnNames: function(n) {
        for(var i=0; i<n; i++) {
          if(!this.splitColNames[i]) {
            this.splitColNames[i] = 'split'+(i+1);
          }
        }
        if(n<this.splitColNames.length) {
          this.splitColNames.splice(0,n);
        }
      },

      _splitNameChanged: function(e, detail, selection) {
        var index = selection.getAttribute('index');
        this.splitColNames[index] = selection.value;
        this._calculateOutput();
      },

      /**
       *  Fired automatically when 'splitColNames' are changed.
       *  This event parses the splitColNames, then
       *  calls a private event to recalculate output.
       *  
       *  @event splitColNamesChanged
       */
      splitColNamesChanged: function() {
        var self = this;
        this._calculateOutput();
      },

      showControls: function(e) {
        this.$.ctrl_collapse.toggle();
      },


      /**
       *  Fired automatically when 'splitCol' is changed.
       *  This event parses the new data, then
       *  calls a private event to recalculate output.
       *  
       *  @event splitColChanged
       */
      splitColChanged: function(e) {
        var self = this;
        self._calculateOutput();
      }

    });
  </script>
</polymer-element>